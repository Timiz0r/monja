use std::fs;

use googletest::prelude::*;

use crate::sim::{Simulator, set_names};
use monja::{
    AbsolutePath, LocalStateInitializationError, MonjaProfileConfig, MonjaProfileConfigError,
    PushError, SetName,
};

#[allow(dead_code)]
#[macro_use]
mod sim;

// since testing this code requires an index file generated by a pull, basically all of these tests will pull first.
// we assume pull works based on the pull tests, so this isn't a particular issue.
// therefore, we won't do LocalValidation

#[gtest]
fn simple_set() -> Result<()> {
    let sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        ..old
    });

    fs_operation! { SetManipulation, sim, "simple",
        dir "foo"
            dir "bar/baz"
                file "cake" "cake"
            end
        end
        dir "apple"
            file "pie" "pie"
            file "pasta" "pasta"
        end
        file "blueberry" "tart"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options())?;

    fs_operation! { LocalManipulation, sim,
        dir "apple"
            file "pie" "nopie"
            file "pasta" "nopasta"
        end
        file "newfile" "newfile"
    };

    let _push_result = monja::push(&sim.profile()?, sim.execution_options())?;

    fs_operation! { SetValidation, sim, "simple",
        dir "foo"
            dir "bar/baz"
                file "cake" "cake"
            end
        end
        dir "apple"
            file "pie" "nopie"
            file "pasta" "nopasta"
        end
        file "blueberry" "tart"
        // and no newfile, since not in index
    };

    Ok(())
}

#[gtest]
fn multi_set() -> Result<()> {
    let sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["set1", "set2"]),
        ..old
    });

    fs_operation! { SetManipulation, sim, "set1",
        dir "foo"
            dir "bar"
                file "baz" "set1baz"
            end
        end
        file "set1only" "set1only"
    };
    fs_operation! { SetManipulation, sim, "set2",
        dir "foo"
            dir "bar"
                file "baz" "set2baz"
            end
        end
        file "set2only" "set2only"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options())?;

    fs_operation! { LocalManipulation, sim,
        dir "foo/bar"
            file "baz" "stillset2"
        end
        file "set1only" "stillset1"
        file "set2only" "stillset2"
    };

    let _push_result = monja::push(&sim.profile()?, sim.execution_options())?;

    fs_operation! { SetValidation, sim, "set1",
        dir "foo"
            dir "bar"
                // push should have pushed to set2, so this doesn't change
                file "baz" "set1baz"
            end
        end
        file "set1only" "stillset1"
    };

    fs_operation! { SetValidation, sim, "set2",
        dir "foo"
            dir "bar"
                file "baz" "stillset2"
            end
        end
        file "set2only" "stillset2"
    };

    Ok(())
}

#[gtest]
fn missing_set() -> Result<()> {
    let sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        ..old
    });

    fs_operation! { SetManipulation, sim, "simple",
        file "blueberry" "tart"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options())?;

    sim.rem_set(SetName("simple".into()));

    let push_result = monja::push(&sim.profile()?, sim.execution_options());
    expect_that!(
        push_result,
        err(pat!(PushError::Consistency {
            files_with_missing_sets: len(eq(1)),
            missing_files: is_empty()
        }))
    );

    Ok(())
}

#[gtest]
fn missing_files() -> Result<()> {
    let sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        ..old
    });

    fs_operation! { SetManipulation, sim, "simple",
        file "blueberry" "tart"
        file "apple" "pie"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options())?;

    fs_operation! { SetManipulation, sim, "simple",
        remfile "blueberry"
    };

    let push_result = monja::push(&sim.profile()?, sim.execution_options());
    expect_that!(
        push_result,
        err(pat!(PushError::Consistency {
            files_with_missing_sets: is_empty(),
            missing_files: len(eq(1))
        }))
    );

    Ok(())
}

#[gtest]
fn missing_repo_folder_pre_profile() -> Result<()> {
    let sim = Simulator::create();

    // since the simulator is responsible for cleaning up its temp folder, we'll make our own to delete
    let temp_repo_root = tempfile::Builder::new()
        .prefix("ToBeDeletedMonjaRepo")
        .tempdir()?;
    let repo_root = AbsolutePath::for_existing_path(temp_repo_root.path())?;

    sim.configure_profile(|_| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        repo_dir: repo_root.to_path_buf(),
    });

    fs_operation! { SetManipulation, sim, "simple",
        file "blueberry" "tart"
        file "apple" "pie"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options());

    std::mem::drop(temp_repo_root);

    // versus actually getting to push, we should fail when trying to create a profile
    // which actually kinda means this test could go in pull.rs, as well
    let profile_result = sim.profile();
    expect_that!(profile_result, err(pat!(MonjaProfileConfigError::Load(..))));

    Ok(())
}

#[gtest]
fn missing_repo_folder_post_profile() -> Result<()> {
    let sim = Simulator::create();

    // since the simulator is responsible for cleaning up its temp folder, we'll make our own to delete
    let temp_repo_root = tempfile::Builder::new()
        .prefix("ToBeDeletedMonjaRepo")
        .tempdir()?;
    let repo_root = AbsolutePath::for_existing_path(temp_repo_root.path())?;

    sim.configure_profile(|_| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        repo_dir: repo_root.to_path_buf(),
    });

    fs_operation! { SetManipulation, sim, "simple",
        file "blueberry" "tart"
        file "apple" "pie"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options());

    let profile = sim.profile()?;
    std::mem::drop(temp_repo_root);

    let push_result = monja::push(&profile, sim.execution_options());
    expect_that!(
        push_result,
        err(pat!(PushError::RepoStateInitialization(_)))
    );

    Ok(())
}

#[gtest]
fn no_index() -> Result<()> {
    let sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        ..old
    });

    fs_operation! { LocalManipulation, sim,
        file "blueberry" "tart"
    };

    // let _pull_result = monja::pull(&sim.profile()?)?;
    // no pull, no index

    let push_result = monja::push(&sim.profile()?, sim.execution_options())?;
    expect_that!(push_result.files_pushed, is_empty());

    Ok(())
}

#[gtest]
fn index_based_directory_traversal_absolute() -> Result<()> {
    let sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        ..old
    });

    fs_operation! { SetManipulation, sim, "simple",
        file "blueberry" "tart"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options())?;

    // a bit of a leaky implementation detail, but oh well
    let index_path = sim.profile()?.data_root.join("monja-index.toml");
    assert_that!(index_path.exists(), is_true());

    let replacement_index = r#""/etc/passwd" = "simple""#;
    fs::write(index_path, replacement_index)?;

    let push_result = monja::push(&sim.profile()?, sim.execution_options());

    let specific_error = pat!(LocalStateInitializationError::FileIndex(_));
    expect_that!(
        push_result,
        err(pat!(PushError::LocalStateInitialization(specific_error)))
    );

    Ok(())
}

#[gtest]
fn index_based_directory_traversal_relative() -> Result<()> {
    let sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        ..old
    });

    fs_operation! { SetManipulation, sim, "simple",
        file "blueberry" "tart"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options())?;

    // a bit of a leaky implementation detail, but oh well
    let index_path = sim.profile()?.data_root.join("monja-index.toml");
    assert_that!(index_path.exists(), is_true());

    let foo_path = sim.profile()?.local_root.join("../foo");
    fs::write(foo_path, "foo")?;

    let replacement_index = r#""../foo" = "simple""#;
    fs::write(index_path, replacement_index)?;

    let push_result = monja::push(&sim.profile()?, sim.execution_options())?;

    // since this file lives outside of the local root, it shouldn't get picked up whether or not it's mentioned in the index
    // this is because we do a full scan of the directory to find inconsistencies and flag them for the user/recover.
    expect_that!(push_result.files_pushed, is_empty());

    Ok(())
}

#[gtest]
fn dry_run() -> Result<()> {
    let mut sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        ..old
    });

    fs_operation! { SetManipulation, sim, "simple",
        dir "foo"
            dir "bar/baz"
                file "cake" "cake"
            end
        end
        dir "apple"
            file "pie" "pie"
            file "pasta" "pasta"
        end
        file "blueberry" "tart"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options())?;

    fs_operation! { LocalManipulation, sim,
        dir "apple"
            file "pie" "nopie"
            file "pasta" "nopasta"
        end
        file "newfile" "newfile"
    };

    sim.dryrun(true);
    let _push_result = monja::push(&sim.profile()?, sim.execution_options())?;

    fs_operation! { SetValidation, sim, "simple",
        dir "foo"
            dir "bar/baz"
                file "cake" "cake"
            end
        end
        dir "apple"
            file "pie" "pie"
            file "pasta" "pasta"
        end
        file "blueberry" "tart"
    };

    Ok(())
}

#[gtest]
fn ignore() -> Result<()> {
    let sim = Simulator::create();
    sim.configure_profile(|old| MonjaProfileConfig {
        target_sets: set_names(["simple"]),
        ..old
    });

    fs_operation! { SetManipulation, sim, "simple",
        file "blueberry" "tart"
    };

    let _pull_result = monja::pull(&sim.profile()?, sim.execution_options())?;

    fs_operation! { LocalManipulation, sim,
        file "blueberry" "pie"
    };

    sim.configure_ignorefile("blueberry");

    let push_result = monja::push(&sim.profile()?, sim.execution_options())?;
    expect_that!(push_result.files_pushed, is_empty());

    fs_operation! { SetValidation, sim, "simple",
        file "blueberry" "tart"
    };

    Ok(())
}
